# デザインパターンについて
<!-- TOC -->

- [デザインパターンについて](#デザインパターンについて)
  - [GoTデザインパターンとは](#gotデザインパターンとは)
  - [生成に関わるパターン](#生成に関わるパターン)
  - [構造に関するパターン](#構造に関するパターン)
  - [振る舞いに関するパターン](#振る舞いに関するパターン)

<!-- /TOC -->
## GoTデザインパターンとは
オブジェクト指向言語を使ったプログラミング全般に共通な汎用デザインパターン
23種類のデザインパターンが存在する
オブジェクト指向を設計するに当たり、どんな機能・役割を持つオブジェクトクラスを定義して組み合わせればいいかを考えた結果作られている

## 生成に関わるパターン

|名前|概要|目的|効果|
|----|---|---|---|
|Factory Method|インスタンス生成をサブクラスにまかせる|あるサブクラスと別のサブクラスを必ずペアで使う|サブクラスの種類を増やしやすくなる|
|Abstract Factory|関連する部品を組み合わせて製品を作る|組み合わせて使う多数のサブクラス群をまとめて交換できるようにしたい|クライアントプログラムを修正すること無く、一連のサブクラス群を実行環境の変更などに伴って交換することが出来るようになる|
|Builder|複雑なインスタンスを組み立てる|複雑な手順でオブジェクトを生成したい|複数のメソッドを呼ぶことで1このオブジェクトを生成させ、通常のコンストラクタでは出来ない複雑な初期値のオブジェクトを生成できる|
|Prototype|コピーしてインスタンスを作成する|いろんな酒類のオブジェクトをたくさん作りたい|コンストラクタに初期パラメーターを渡さなくても、簡単に所望の酒類のオブジェクトを入手することが出来る|
|Singleton|あるクラスのインスタンスは１つしか無いことを保証する|あるクラスのオブジェクトを1個だけ作って共有したい|システムの起動から終了までの間に、そのクラスのオブジェクトが1個しか存在しないことを保証する|

## 構造に関するパターン

|名前|概要|目的|効果|
|----|---|---|---|
|Adapter|適合させる|既存のクラスに別のインターフェースを持たせたい|既存のクラスを修正すること無く、適切なインターフェースを追加することが出来る|
|Bridge|機能の階層と実装の階層を分ける|関連の強いクラスを互いに影響しないようにしたまま拡張したい|関連の強い2つのクラスについて、それぞれのクラスを継承して拡張したサブクラスを作っても、相手クラスのコードは何も変更しなくて済む(影響しない)ようになる|
|Composite|容器と中身の同一視|階層構造をなすオブジェクト全体に再帰的に一連の操作を実行したい|階層構造をなすオブジェクト全体に、1会のメソッド呼び出しで一連の操作を再帰的に実行する事ができる|
|Decorator|飾り枠と中身の同一視|既存のクラスのインターフェースを変更せずに機能を追加したい|クラスの継承よりも自由度が高い方法で機能を追加できる|
|Facade|見かけをシンプルに|既存クラスを複数組み合わせて使う手段を定石化したい|既存クラスの使い方(メソッドの呼び方)のうち、汎用性の高いものを開発者間で共有しあうことで、開発スピードをあげたり、バグを減らすことが出来る|
|Flyweight|同じものを共有して軽量化|小さくて軽いオブジェクトをたくさん作りたい|オブジェクトの生成/保持に必要な負荷を小さくすることが出来る|
|Proxy|代理人|あるオブジェクトがほかからアクセスされた時フックしたい|既存のクラスのいずれかのメソッドが呼ばれた時に、それをふっくして処理を加える事が出来る|

## 振る舞いに関するパターン


|名前|概要|目的|効果|
|----|---|---|---|
|Chain of Responsibility|責任の連鎖|1つのリクエストを複数のオブジェクトのいずれかで処理させたい|あるリクエストを処理するのに適切なオブジェクトをたくさんの中から選んで処理させることが簡単に出来る|
|Command|命令|複雑な内容のリクエストを送れるようにしたい|リクエストの処理自体をオブジェクト化することで、どんなに複雑な内容のリクエストでも送れるし、リクエストの種類を好きなように増やすことも出来る|
|Interpreter|文法規則をクラスで表現|構文解析の結果を実行したい|構文解析の結果として得られるオブジェクト構造をそのまま使ってインタプリタを実行できるので、構文を拡張しやすくなる|
|Iterator|繰り返し|ごちゃごちゃと蓄積されたオブジェクト群に順番にアクセスしたい|オブジェクト群がどういう構造で保持されているかに関係なく、シンプルに統一されたインタフェースでアクセス出来るようになる|
|Mediator|多数のオブジェクトの調整|複数の部品オブジェクトを相互作用させたい|相互作用の内容の変更や部品オブジェクトの追加が簡単に行える|
|Memento|状態を保持する|オブジェクトの状態をいつでも戻せるようにしたい|オブジェクトのある瞬間での状態(インスタンス変数の値)のスナップショットを取り出して保存しておき、それを使って元の状態を復元できる|
|Observer|状態の変化を通知する|自分以外のオブジェクトの状態が変化したことをチェックしたい|チェックする側とされる側のクラスを切り替えたり増やしたりすることが簡単に出来るようになる|
|State|状態をクラスとして表現する|オブジェクトの処理内容を状況に応じて切り替えたい|状況が複雑に変化しても処理内容の切り替えがシンプルに行え、コード内での状態遷移の見通しが良くなる|
|Strategy|アルゴリズムを交換する|いろんなアルゴリズムを交換しながらプログラムを実行したい|プログラムの実行中に、その中で使われるアルゴリズムを簡単に切り替えることが出来る|
|Template Method|具体的な処理をサブクラスにまかせる|大きな処理を部分的に変更できるようにしたい|ある１つの大きな処理を複数のステップに分解し、ステップの実行順序は守りつつ、各ステップごとに処理内容を変更できる|
|Visitor|オブジェクトに動的に追加するための工夫|たくさんのオブジェクトの集合に処理を追加したい|オブジェクトの集合の中に何種類かのクラスが混在していても、それらのクラスを修正すること無く処理を追加することが出来る|
